- hosts: localhost
  become: yes
  gather_facts: yes
  tags:
    - all

  tasks:
    - name: Gather system facts
      setup:
      tags: always

    # üîπ Configure Hostname
    - name: Configure system hostname
      block:
        - name: Prompt for new hostname
          ansible.builtin.pause:
            prompt: "Enter new hostname"
          register: hostname_input
          become: false
          tags: hostname

        - name: Set hostname (MacOS)
          shell: |
            scutil --set ComputerName "{{ hostname_input.user_input }}"
            scutil --set LocalHostName "{{ hostname_input.user_input }}"
            scutil --set HostName "{{ hostname_input.user_input }}"
          when: ansible_facts['os_family'] == "Darwin" or ansible_facts['os_family'] == "MacOS" or ansible_facts['os_family'] == "macOS"
          become: true
          tags: hostname

        - name: Set hostname (Ubuntu)
          hostname:
            name: "{{ hostname_input.user_input }}"
          when: ansible_facts['os_family'] == "Debian"
          become: true
          tags: hostname

      rescue:
        - name: Log hostname configuration failure
          debug:
            msg: "‚ö†Ô∏è Hostname configuration failed, continuing."
          tags: hostname

    # üîπ Install Homebrew (Mac only)
    - name: Install Homebrew (macOS)
      block:
        - name: Install Homebrew
          shell: >
            /bin/zsh -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          args:
            creates: /usr/local/bin/brew
          become: false
          when: ansible_facts['os_family'] == "Darwin" or ansible_facts['os_family'] == "MacOS" or ansible_facts['os_family'] == "macOS"
          tags: homebrew
      rescue:
        - name: Log Homebrew installation failure
          debug:
            msg: "‚ö†Ô∏è Homebrew installation failed, continuing."
          tags: homebrew

    # üîπ Install CLI tools (Mac & Linux)
    - name: Install Mac CLI tools
      block:
        - name: Install Mac CLI tools via Homebrew
          homebrew:
            name:
              - zsh
              - neovim
              - curl
              - git
              - jq
              - make
              - docker
              - nnn
              - borgbackup
              - node
              - stow
              - pylint
            state: present
          become: false
          when: ansible_facts['os_family'] == "Darwin" or ansible_facts['os_family'] == "MacOS" or ansible_facts['os_family'] == "macOS"
      when: ansible_facts['os_family'] == "Darwin" or ansible_facts['os_family'] == "MacOS" or ansible_facts['os_family'] == "macOS"
      tags: cli
      rescue:
        - name: Log Mac CLI tool installation failure
          debug:
            msg: "‚ö†Ô∏è CLI tools installation failed on Mac, continuing."
          tags: cli

    - name: Install Ubuntu CLI tools
      block:
        - name: Check if snap Docker is installed
          command: snap list docker
          register: snap_docker_check
          failed_when: false
          changed_when: false
          become: false
          tags: cli

        - name: Remove snap Docker if installed
          shell: snap remove docker
          become: false
          failed_when: false
          when: 
            - ansible_facts['os_family'] == "Debian"
            - snap_docker_check.rc == 0
          tags: cli

        - name: Remove conflicting containerd package (if exists)
          apt:
            name: containerd
            state: absent
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: cli

        - name: Install Ubuntu CLI tools via APT
          apt:
            name:
              - zsh
              - neovim
              - curl
              - git
              - jq
              - make
              - docker.io
              - docker-compose-plugin
              - nnn
              - syncthing
              - borgbackup
              - net-tools
              - chrome-gnome-shell
              - input-remapper
              - ufw
              - stow
              - pylint
              - qbittorrent-nox
              - transmission-daemon
              - plexmediaserver
              - redis-server
              - openvpn
              - wireguard
              - wireguard-tools
              - inotify-tools
            state: present
            update_cache: yes
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: cli

        - name: Check if docker group exists
          command: getent group docker
          register: docker_group_check
          failed_when: false
          changed_when: false
          become: false
          tags: cli

        - name: Create docker group if it doesn't exist
          group:
            name: docker
            state: present
          become: true
          when: docker_group_check.rc != 0
          tags: cli

        - name: Add user to docker group
          user:
            name: "{{ lookup('env', 'USER') }}"
            groups: docker
            append: yes
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: cli

        - name: Ensure Docker socket has correct permissions
          file:
            path: /var/run/docker.sock
            owner: root
            group: docker
            mode: '0660'
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: cli

        - name: Ensure Docker service is enabled and started
          systemd:
            name: docker
            state: started
            enabled: yes
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: cli
      rescue:
        - name: Log Ubuntu CLI tool installation failure
          debug:
            msg: "‚ö†Ô∏è CLI tools installation failed on Ubuntu, continuing."
          tags: cli

    # üîπ Install GUI Apps - MacOS
    - name: Install GUI apps - MacOS
      block:
        - name: Install GUI apps - MacOS
          homebrew_cask:
            name:
              - arc
              - visual-studio-code
              - brave-browser
              - tor-browser
              - firefox
              - zettlr
              - syncthing
              - notion
              - itsycal
              - hiddenbar
              - rustdesk
              - bettertouchtool
              - wireguard
              - cursor
              - maccy
              - itsycal
              - spotify
              - soulseek
              - steam
              - zoom
              - libreoffice
              - protonvpn
              - notunes
            state: present
          become: false
          when: ansible_facts['os_family'] == "Darwin" or ansible_facts['os_family'] == "MacOS" or ansible_facts['os_family'] == "macOS"
          tags: gui

        - name: Install Docker Desktop for MacOS
          shell: brew install --cask docker
          become: false
          when: ansible_facts['os_family'] == "Darwin" or ansible_facts['os_family'] == "MacOS" or ansible_facts['os_family'] == "macOS"
          tags: gui

        - name: Configure NoTunes to replace Apple Music with Spotify
          shell: defaults write digital.twisted.noTunes replacement /Applications/Spotify.app
          become: false
          when: ansible_facts['os_family'] == "Darwin" or ansible_facts['os_family'] == "MacOS" or ansible_facts['os_family'] == "macOS"
          tags: gui

      when: ansible_facts['os_family'] == "Darwin" or ansible_facts['os_family'] == "MacOS" or ansible_facts['os_family'] == "macOS"
      tags: gui
      rescue:
        - name: Log Mac GUI apps installation failure
          debug:
            msg: "‚ö†Ô∏è GUI apps installation failed on Mac, continuing."
          tags: gui

    # üîπ Install GUI Apps - Ubuntu
    - name: Install GUI apps - Ubuntu
      block:
        - name: Add Brave Browser repository
          shell: |
            sudo apt install curl -y
            sudo curl -fsSLo /usr/share/keyrings/brave-browser-archive-keyring.gpg https://brave-browser-apt-release.s3.brave.com/brave-browser-archive-keyring.gpg
            echo "deb [signed-by=/usr/share/keyrings/brave-browser-archive-keyring.gpg] https://brave-browser-apt-release.s3.brave.com/ stable main" | sudo tee /etc/apt/sources.list.d/brave-browser-release.list
            sudo apt update
          args:
            creates: /etc/apt/sources.list.d/brave-browser-release.list
          tags: gui

        - name: Add ProtonVPN repository
          shell: |
            sudo apt update
            sudo apt install -y wget
            wget -qO - https://repo.protonvpn.com/debian/public_key.asc | sudo apt-key add -
            echo "deb https://repo.protonvpn.com/debian stable main" | sudo tee /etc/apt/sources.list.d/protonvpn-stable-release.list
            sudo apt update
          args:
            creates: /etc/apt/sources.list.d/protonvpn-stable-release.list
          tags: gui

        - name: Add Docker Desktop repository
          shell: |
            sudo apt-get update
            sudo apt-get install -y ca-certificates curl gnupg
            sudo install -m 0755 -d /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            sudo chmod a+r /etc/apt/keyrings/docker.gpg
            echo "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt-get update
          tags: gui

        - name: Install Docker Desktop and other GUI apps
          apt:
            name:
              - brave-browser
              - torbrowser-launcher
              - docker-ce
              - docker-ce-cli
              - containerd.io
              - docker-buildx-plugin
              - docker-compose-plugin
              - docker-desktop
              - protonvpn
            state: present
          tags: gui

        - name: Install VS Code (Snap)
          snap:
            name: code
            classic: yes
          tags: gui

        - name: Install Syncthing (Ubuntu)
          apt:
            name: syncthing
            state: present
          tags: gui

        - name: Install Rustdesk (Ubuntu)
          apt:
            name: rustdesk
            state: present
          tags: gui

      when: ansible_facts['os_family'] == "Debian"
      tags: gui
      rescue:
        - name: Log Ubuntu GUI apps installation failure
          debug:
            msg: "‚ö†Ô∏è GUI apps installation failed on Ubuntu, continuing."
          tags: gui

    - name: Configure SSH and clone all GitHub repos
      block:
        - name: Ensure .ssh directory exists with correct permissions
          ansible.builtin.file:
            path: "{{ lookup('env', 'HOME') }}/.ssh"
            state: directory
            mode: '0700'
            owner: "{{ lookup('env', 'USER') }}"
          become: false
          tags: ssh, clone

        - name: Generate SSH key if it doesn't exist
          ansible.builtin.command: "ssh-keygen -t rsa -b 4096 -f {{ lookup('env', 'HOME') }}/.ssh/id_rsa -N ''"
          args:
            creates: "{{ lookup('env', 'HOME') }}/.ssh/id_rsa"
          register: keygen_result
          become: false
          tags: ssh, clone

        - name: Display new SSH key and wait for GitHub setup
          block:
            - name: Display SSH key
              ansible.builtin.debug:
                msg: |
                  üîë Add this SSH key to GitHub, ignoring ###:
                  ###{{ lookup('file', lookup('env', 'HOME') + '/.ssh/id_rsa.pub') }}###
              changed_when: false
              become: false
              tags: ssh, clone

            - name: Wait for user to add key to GitHub
              ansible.builtin.pause:
                prompt: "Press Enter after you have added the SSH key to GitHub"
              tags: ssh, clone
          when: keygen_result.changed
          tags: ssh, clone

        - name: Test SSH connection to GitHub
          ansible.builtin.command: "ssh -T git@github.com"
          register: ssh_test
          failed_when: ssh_test.rc != 1  # Expecting "Hi <user>! You've successfully authenticated, but GitHub does not provide shell access."
          changed_when: false
          become: false
          tags: ssh, clone

        - name: Ensure git directory exists
          ansible.builtin.file:
            path: "{{ lookup('env', 'HOME') }}/git"
            state: directory
            mode: '0755'
            owner: "{{ lookup('env', 'USER') }}"
          become: false
          tags: clone

        - name: Clone repositories using SSH
          ansible.builtin.shell: >
            UserName=tylerjwoodfin;
            curl -s https://api.github.com/users/$UserName/repos?per_page=1000 |
            jq -r '.[] | select(.archived == false) | .ssh_url' | xargs -I {} git clone {}
          args:
            chdir: "{{ lookup('env', 'HOME') }}/git"
          become: false
          tags: clone

      rescue:
        - name: Log repo cloning failure
          ansible.builtin.debug:
            msg: "‚ö†Ô∏è Cloning GitHub repositories failed, continuing."
          tags: clone

    # üîπ Install Miscellaneous Tools
    - name: Install CopyQ (Clipboard Manager)
      block:
        - name: Install CopyQ
          apt:
            name: copyq
            state: present
          when: ansible_facts['os_family'] == "Debian"
          tags: copyq
      rescue:
        - name: Log CopyQ installation failure
          debug:
            msg: "‚ö†Ô∏è CopyQ installation failed, continuing."
          tags: copyq

    - name: Install Pihole
      block:
        - name: Install PiHole dependencies
          apt:
            name: 
              - curl
              - wget
              - git
            state: present
          when: ansible_facts['os_family'] == "Debian"
          tags: pihole

        - name: Install PiHole
          ansible.builtin.shell:
            cmd: "curl -sSL https://install.pi-hole.net | bash -s -- --unattended"
            executable: /bin/bash
          become: true
          args:
            creates: /etc/pihole/setupVars.conf
          when: ansible_facts['os_family'] == "Debian"
          tags: pihole
      rescue:
        - name: Log PiHole installation failure
          ansible.builtin.debug:
            msg: "‚ö†Ô∏è PiHole installation failed, continuing."
          tags: pihole

    # üîπ Install Cabinet and Remindmail
    - name: Ensure pipx is installed
      block:
        - name: Install pipx via Homebrew
          homebrew:
            name: pipx
            state: present
          become: false
          when: ansible_facts['os_family'] == "Darwin" or ansible_facts['os_family'] == "MacOS" or ansible_facts['os_family'] == "macOS"
          tags: python

        - name: Install pipx via APT
          apt:
            name: pipx
            state: present
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: python

    - name: Ensure pipx is in PATH
      ansible.builtin.blockinfile:
        path: "{{ lookup('env', 'HOME') }}/.zshrc"
        marker: "# {mark} ANSIBLE MANAGED BLOCK - PIPX"
        block: |
          export PATH="$HOME/.local/bin:$PATH"
        create: yes
      become: false
      tags: python

    - name: Install Cabinet (Python Package via pipx)
      block:
        - name: Install Cabinet via pipx
          ansible.builtin.shell: "pipx install cabinet"
          args:
            executable: /bin/bash
          become: false
          tags: python

      rescue:
        - name: Log Cabinet installation failure
          ansible.builtin.debug:
            msg: "‚ö†Ô∏è Cabinet Python package installation failed, continuing."
          tags: python

    - name: Install RemindMail (Python Package via pipx)
      block:
        - name: Install RemindMail via pipx
          ansible.builtin.shell: "pipx install remindmail"
          args:
            executable: /bin/bash
          become: false
          tags: python

      rescue:
        - name: Log RemindMail installation failure
          ansible.builtin.debug:
            msg: "‚ö†Ô∏è RemindMail Python package installation failed, continuing."
          tags: python


    # üîπ MacOS Defaults
    - name: Apply MacOS defaults
      block:
        - name: Execute mac.sh script using zsh
          ansible.builtin.command:
            cmd: zsh ../scripts/mac.sh
          args:
            chdir: "{{ playbook_dir }}"
          register: script_output
          tags: mac_defaults

        - name: Show script output
          debug:
            var: script_output.stdout
          when: ansible_facts['os_family'] == "Darwin"
          tags: mac_defaults
      rescue:
        - name: Log MacOS defaults script failure
          debug:
            msg: "‚ö†Ô∏è mac.sh execution failed, continuing."
          tags: mac_defaults

    # üîπ Configure Git
    - name: Configure Git settings
      vars:
        git: "{{ lookup('env', 'HOME') }}/git"
      block:
        - name: Apply Pre-push hooks
          shell: zsh {{ git }}/tools/githooks/apply_pre-push.sh
          args:
            executable: /bin/zsh
          become: false
          tags: git

        - name: Set Git email defaults
          ansible.builtin.git_config:
            name: user.email
            value: 14207553+tylerjwoodfin@users.noreply.github.com
            scope: global
          become: false
          tags: git

        - name: Set Git name defaults
          ansible.builtin.git_config:
            name: user.name
            value: "Tyler Woodfin"
            scope: global
          become: false
          tags: git

      rescue:
        - name: Log Git configuration failure
          debug:
            msg: "‚ö†Ô∏è Git configuration failed, continuing."
          tags: git

    # üîπ Configure SSH Authorized Keys
    - name: Apply the shared authorized_keys file
      block:
        - name: Update sshd_config with authorized_keys file path
          ansible.builtin.lineinfile:
            path: /etc/ssh/sshd_config
            regexp: '^AuthorizedKeysFile'
            line: "AuthorizedKeysFile %h/.ssh/authorized_keys {{ lookup('env', 'HOME') }}/git/backend/authorized_keys.md"
            state: present
          become: true
          tags: ssh

        - name: Set authorized_keys notice
          copy:
            content: |
              # this file is empty.
              # authorized public keys are stored in ~/git/backend/authorized_keys.md.
              # For instructions, see `NOTION/Docs/selfhosted/ssh and sftp for cloud and rainbow` for instructions.
              # this notice was updated on 2025-10-07
            dest: "{{ lookup('env', 'HOME') }}/.ssh/authorized_keys"
            mode: '0644'
          become: false
          tags: ssh

        - name: Set git directory permissions
          file:
            path: "{{ lookup('env', 'HOME') }}/git"
            mode: '0755'
          become: false
          tags: ssh

        - name: Set backend directory permissions
          file:
            path: "{{ lookup('env', 'HOME') }}/git/backend"
            mode: '0755'
          become: false
          tags: ssh

        - name: Set authorized_keys.md permissions
          file:
            path: "{{ lookup('env', 'HOME') }}/git/backend/authorized_keys.md"
            mode: '0600'
          become: false
          tags: ssh

        - name: Ensure correct directory permissions
          ansible.builtin.file:
            path: "{{ lookup('env', 'HOME') }}"
            state: directory
            mode: '0700'
            recurse: yes
          become: false
          tags: ssh

        - name: Ensure correct ownership of directories
          ansible.builtin.file:
            path: "{{ lookup('env', 'HOME') }}"
            state: directory
            owner: "{{ lookup('env', 'USER') }}"
            recurse: yes
          become: false
          tags: ssh

        - name: Configure UFW
          ufw:
            rule: allow
            name: OpenSSH
            state: enabled
            policy: deny
            default_deny: yes
            allow_ssh: yes
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: ssh

        - name: Restart SSH service (Linux only)
          systemd:
            name: sshd
            state: restarted
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: ssh

      rescue:
        - name: Log SSH configuration failure
          debug:
            msg: "‚ö†Ô∏è SSH authorized_keys setup failed, continuing."
          tags: ssh

    # üîπ Configure Fail2Ban
    - name: Configure Fail2Ban
      block:
        - name: Install fail2ban
          apt:
            name: fail2ban
            state: present
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: fail2ban

        - name: Configure fail2ban jail.local
          copy:
            content: |
              [DEFAULT]
              bantime = 1h
              findtime = 10m
              maxretry = 5
              banaction = iptables-multiport
              backend = auto

              [sshd]
              enabled = true
              port = ssh
              filter = sshd
              logpath = /var/log/auth.log
              maxretry = 3
              findtime = 300
              bantime = 3600
            dest: /etc/fail2ban/jail.local
            mode: '0644'
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: fail2ban

        - name: Ensure fail2ban service is enabled and started
          systemd:
            name: fail2ban
            state: started
            enabled: yes
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: fail2ban

      rescue:
        - name: Log fail2ban configuration failure
          debug:
            msg: "‚ö†Ô∏è fail2ban configuration failed, continuing."
          tags: fail2ban

    - name: Set Zsh as the default shell
      block:
        - name: Ensure Zsh is installed
          ansible.builtin.package:
            name: zsh
            state: present
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: zsh

        - name: Change default shell to Zsh
          ansible.builtin.shell: "chsh -s $(which zsh) {{ lookup('env', 'USER') }}"
          become: true
          tags: zsh

      rescue:
        - name: Log failure to set Zsh as default shell
          ansible.builtin.debug:
            msg: "‚ö†Ô∏è Failed to set Zsh as the default shell, continuing."
          tags: zsh

    # üîπ Install Ollama
    - name: Install Ollama
      block:
        - name: Check if Ollama is already installed
          stat:
            path: /usr/local/bin/ollama
          register: ollama_binary
          tags: ollama

        - name: Download and install Ollama
          shell: |
            curl -fsSL https://ollama.com/install.sh | sh
          become: true
          when: not ollama_binary.stat.exists
          tags: ollama

        - name: Create ollama user and group
          user:
            name: ollama
            group: ollama
            system: yes
            shell: /bin/false
            create_home: no
          become: true
          when: not ollama_binary.stat.exists
          tags: ollama

        - name: Create Ollama systemd service
          copy:
            content: |
              [Unit]
              Description=Ollama Service
              After=network-online.target

              [Service]
              ExecStart=/usr/local/bin/ollama serve
              User=ollama
              Group=ollama
              Restart=always
              RestartSec=3
              Environment="PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/tyler/.local/bin"

              [Install]
              WantedBy=default.target
            dest: /etc/systemd/system/ollama.service
            mode: '0644'
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: ollama

        - name: Enable and start Ollama service
          systemd:
            name: ollama
            state: started
            enabled: yes
            daemon_reload: yes
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: ollama

      when: ansible_facts['os_family'] == "Debian"
      tags: ollama
      rescue:
        - name: Log Ollama installation failure
          debug:
            msg: "‚ö†Ô∏è Ollama installation failed, continuing."
          tags: ollama

    # üîπ Install Cloudflared
    - name: Install Cloudflared
      block:
        - name: Check if Cloudflared is already installed
          stat:
            path: /usr/local/bin/cloudflared
          register: cloudflared_binary
          tags: cloudflared

        - name: Download Cloudflared
          get_url:
            url: https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
            dest: /tmp/cloudflared
            mode: '0755'
          become: true
          when: not cloudflared_binary.stat.exists
          tags: cloudflared

        - name: Install Cloudflared binary
          copy:
            src: /tmp/cloudflared
            dest: /usr/local/bin/cloudflared
            mode: '0755'
            remote_src: yes
          become: true
          when: not cloudflared_binary.stat.exists
          tags: cloudflared

        - name: Create Cloudflared systemd service
          copy:
            content: |
              [Unit]
              Description=cloudflared
              After=network-online.target
              Wants=network-online.target

              [Service]
              TimeoutStartSec=0
              Type=notify
              ExecStart=/usr/local/bin/cloudflared --no-autoupdate tunnel run --token {{ cloudflared_token | default('YOUR_TOKEN_HERE') }}
              Restart=on-failure
              RestartSec=5s

              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/cloudflared.service
            mode: '0644'
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: cloudflared

        - name: Note about Cloudflared token configuration
          debug:
            msg: |
              ‚ö†Ô∏è IMPORTANT: Cloudflared configuration required:
              - Edit /etc/systemd/system/cloudflared.service and replace YOUR_TOKEN_HERE with your tunnel token
              - OR if using config files, restore /etc/cloudflared/*.yml config files
              - Template services (cloudflared@gitea.service, cloudflared@immich.service) require config files in /etc/cloudflared/
          tags: cloudflared

        - name: Enable Cloudflared service (user must configure token first)
          systemd:
            name: cloudflared
            enabled: yes
            daemon_reload: yes
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: cloudflared

      when: ansible_facts['os_family'] == "Debian"
      tags: cloudflared
      rescue:
        - name: Log Cloudflared installation failure
          debug:
            msg: "‚ö†Ô∏è Cloudflared installation failed, continuing."
          tags: cloudflared

    # üîπ Install NVM and Node.js (for Immich script)
    - name: Install NVM and Node.js
      block:
        - name: Ensure native curl is installed (not snap)
          apt:
            name: curl
            state: present
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: nvm

        - name: Check if NVM is already installed
          stat:
            path: "{{ lookup('env', 'HOME') }}/.nvm"
          register: nvm_dir
          become: false
          tags: nvm

        - name: Install NVM
          shell: |
            export PATH="/usr/bin:/bin:$PATH"
            /usr/bin/curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
          args:
            executable: /bin/bash
          become: false
          when: not nvm_dir.stat.exists
          tags: nvm

        - name: Ensure NVM cache directory has correct permissions
          file:
            path: "{{ lookup('env', 'HOME') }}/.nvm/.cache"
            state: directory
            mode: '0755'
            owner: "{{ lookup('env', 'USER') }}"
            recurse: yes
          become: false
          tags: nvm

        - name: Ensure NVM is configured in .zshrc
          ansible.builtin.blockinfile:
            path: "{{ lookup('env', 'HOME') }}/.zshrc"
            marker: "# {mark} ANSIBLE MANAGED BLOCK - NVM"
            block: |
              export NVM_DIR="$HOME/.nvm"
              [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
              [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
            create: yes
          become: false
          tags: nvm

        - name: Source NVM and install Node.js v20.18.0
          shell: |
            export PATH="/usr/bin:/bin:$PATH"
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            nvm install 20.18.0
            nvm use 20.18.0
            nvm alias default 20.18.0
          args:
            executable: /bin/bash
          become: false
          environment:
            PATH: "/usr/bin:/bin:{{ ansible_env.PATH }}"
          tags: nvm

      when: ansible_facts['os_family'] == "Debian"
      tags: nvm
      rescue:
        - name: Log NVM installation failure
          debug:
            msg: "‚ö†Ô∏è NVM installation failed, continuing."
          tags: nvm

    # üîπ Configure Immich Upload Service
    - name: Configure Immich Upload Service
      block:
        - name: Ensure backend/log-backup directory exists
          ansible.builtin.file:
            path: "{{ lookup('env', 'HOME') }}/git/backend/log-backup/{{ ansible_hostname }}"
            state: directory
            mode: '0755'
            owner: "{{ lookup('env', 'USER') }}"
          become: false
          tags: immich

        - name: Create Immich Upload systemd service
          copy:
            content: |
              [Unit]
              Description=Automatically upload photos from Syncthing

              [Service]
              ExecStart=/bin/zsh {{ lookup('env', 'HOME') }}/git/tools/immich/immich.sh
              Restart=always
              RestartSec=5
              User={{ lookup('env', 'USER') }}
              Environment=HOME={{ lookup('env', 'HOME') }}
              Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:{{ lookup('env', 'HOME') }}/.nvm/versions/node/v20.18.0/bin
              Environment=NVM_DIR={{ lookup('env', 'HOME') }}/.nvm
              Environment=ZDOTDIR={{ lookup('env', 'HOME') }}
              StandardOutput=append:{{ lookup('env', 'HOME') }}/git/backend/log-backup/{{ ansible_hostname }}/immich.log
              StandardError=append:{{ lookup('env', 'HOME') }}/git/backend/log-backup/{{ ansible_hostname }}/immich.log

              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/immich-upload.service
            mode: '0644'
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: immich

        - name: Enable Immich Upload service
          systemd:
            name: immich-upload
            enabled: yes
            daemon_reload: yes
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: immich

      when: ansible_facts['os_family'] == "Debian"
      tags: immich
      rescue:
        - name: Log Immich service configuration failure
          debug:
            msg: "‚ö†Ô∏è Immich service configuration failed, continuing."
          tags: immich

    # üîπ Start Docker Containers
    - name: Start Docker Containers
      block:
        - name: Check if docker directory exists
          stat:
            path: "{{ lookup('env', 'HOME') }}/git/docker"
          register: docker_dir
          become: false
          tags: docker

        - name: Find docker-compose files in docker directory
          find:
            paths: "{{ lookup('env', 'HOME') }}/git/docker"
            patterns:
              - "docker-compose.yml"
              - "docker-compose.yaml"
            file_type: file
            recurse: yes
          register: compose_files
          become: false
          when: docker_dir.stat.exists
          tags: docker

        - name: Start Docker containers from compose files
          shell: |
            cd "{{ item.dir }}"
            docker compose up -d
          args:
            chdir: "{{ item.dir }}"
          become: false
          loop: "{{ compose_files.files | map(attribute='path') | map('dirname') | list | unique }}"
          when:
            - docker_dir.stat.exists
            - compose_files.matched > 0
          tags: docker
          ignore_errors: yes

        - name: Note about Docker containers
          debug:
            msg: |
              ‚ÑπÔ∏è Docker containers:
              {% if docker_dir.stat.exists %}
              - Found docker-compose files in ~/git/docker
              - Attempted to start containers
              {% else %}
              - ~/git/docker directory does not exist, skipping container startup
              - Containers can be started manually after cloning repos
              {% endif %}
          tags: docker

      when: ansible_facts['os_family'] == "Debian"
      tags: docker
      rescue:
        - name: Log Docker container startup failure
          debug:
            msg: "‚ö†Ô∏è Docker container startup failed, continuing. Containers can be started manually."
          tags: docker

    # üîπ Restore Gitea Repositories (backend and docker) from rainbow
    - name: Restore Gitea Repositories from rainbow
      block:
        - name: Check if backend directory exists
          stat:
            path: "{{ lookup('env', 'HOME') }}/git/backend"
          register: backend_dir
          become: false
          tags: gitea-restore

        - name: Check if docker directory exists
          stat:
            path: "{{ lookup('env', 'HOME') }}/git/docker"
          register: docker_dir
          become: false
          tags: gitea-restore

        - name: Get rainbow IP from variable or prompt
          set_fact:
            rainbow_ip: "{{ rainbow_ip | default('') }}"
          tags: gitea-restore

        - name: Prompt for rainbow IP if not provided
          pause:
            prompt: "Please Enter rainbow's IP address."
          register: rainbow_ip_input
          when: rainbow_ip == ''
          tags: gitea-restore

        - name: Set rainbow IP from input
          set_fact:
            rainbow_ip: "{{ rainbow_ip_input.user_input }}"
          when: rainbow_ip == '' and rainbow_ip_input.user_input is defined
          tags: gitea-restore

        - name: Fail if rainbow IP is not set
          fail:
            msg: "Rainbow IP address is required for gitea-restore"
          when: rainbow_ip == '' or rainbow_ip is not defined
          tags: gitea-restore

        - name: Restore backend repository from rainbow
          ansible.builtin.shell: |
            rsync -av --exclude='.git' tyler@{{ rainbow_ip }}:~/git/backend/ {{ lookup('env', 'HOME') }}/git/backend/
          become: false
          when: not backend_dir.stat.exists
          tags: gitea-restore
          ignore_errors: yes

        - name: Restore docker repository from rainbow
          ansible.builtin.shell: |
            rsync -av --exclude='.git' --rsync-path="sudo rsync" tyler@{{ rainbow_ip }}:~/git/docker/ {{ lookup('env', 'HOME') }}/git/docker/ || true
          become: false
          when: not docker_dir.stat.exists
          tags: gitea-restore
          ignore_errors: yes

        - name: Initialize git repo for backend after restore
          ansible.builtin.shell: |
            cd {{ lookup('env', 'HOME') }}/git/backend
            if [ ! -d .git ]; then
              git init
              git remote add origin ssh://git@192.168.1.101:222/voice2749/backend.git || true
              git branch -M master || true
            else
              git remote set-url origin ssh://git@192.168.1.101:222/voice2749/backend.git || true
            fi
          become: false
          when: backend_dir.stat.exists
          tags: gitea-restore
          ignore_errors: yes

        - name: Initialize git repo for docker after restore
          ansible.builtin.shell: |
            cd {{ lookup('env', 'HOME') }}/git/docker
            if [ ! -d .git ]; then
              git init
              git remote add origin ssh://git@192.168.1.101:222/voice2749/docker.git || true
              git branch -M master || true
            else
              git remote set-url origin ssh://git@192.168.1.101:222/voice2749/docker.git || true
            fi
          become: false
          when: docker_dir.stat.exists
          tags: gitea-restore
          ignore_errors: yes

        - name: Note about Gitea repositories
          debug:
            msg: |
              ‚ÑπÔ∏è Gitea repositories (backend and docker):
              {% if backend_dir.stat.exists %}
              - backend directory exists
              {% else %}
              - Restored backend from rainbow
              {% endif %}
              {% if docker_dir.stat.exists %}
              - docker directory exists
              {% else %}
              - Restored docker from rainbow
              {% endif %}
              - After Gitea container is started, you can pull updates with: git pull
          tags: gitea-restore

      when: ansible_facts['os_family'] == "Debian"
      tags: gitea-restore
      rescue:
        - name: Log Gitea restore failure
          debug:
            msg: "‚ö†Ô∏è Failed to restore from rainbow. You may need to manually restore: rsync -av rainbow:~/git/backend ~/git/ && rsync -av rainbow:~/git/docker ~/git/"
          tags: gitea-restore

    # üîπ Configure MongoDB Atlas Routing Services (for ProtonVPN split-tunneling)
    - name: Configure MongoDB Atlas Routing Services
      block:
        - name: Install MongoDB routing scripts
          copy:
            src: "{{ playbook_dir }}/restore/{{ item }}"
            dest: "/usr/local/bin/{{ item }}"
            mode: '0755'
          loop:
            - mongodb-routes.sh
            - mongodb-split-tunnel.sh
            - mongodb-vpn-watcher.sh
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: mongodb-routes

        - name: Install MongoDB systemd services
          copy:
            src: "{{ playbook_dir }}/restore/{{ item }}"
            dest: "/etc/systemd/system/{{ item }}"
            mode: '0644'
          loop:
            - mongodb-routes-monitor.service
            - mongodb-split-tunnel.service
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: mongodb-routes

        - name: Enable and start MongoDB routing services
          systemd:
            name: "{{ item }}"
            enabled: yes
            state: started
            daemon_reload: yes
          become: true
          loop:
            - mongodb-routes-monitor
            - mongodb-split-tunnel
          when: ansible_facts['os_family'] == "Debian"
          tags: mongodb-routes

        - name: Note about MongoDB Atlas routing
          debug:
            msg: |
              ‚ÑπÔ∏è MongoDB Atlas routing services configured:
              - Installed scripts to /usr/local/bin/
              - Installed systemd services
              - Routes MongoDB Atlas IPs (89.192.9.46, 89.192.9.70, 89.192.9.80) to bypass ProtonVPN
          tags: mongodb-routes

      when: ansible_facts['os_family'] == "Debian"
      tags: mongodb-routes
      rescue:
        - name: Log MongoDB routes configuration failure
          debug:
            msg: "‚ö†Ô∏è MongoDB routes configuration failed, continuing."
          tags: mongodb-routes

    # üîπ Restore Additional Custom Services
    - name: Restore Additional Custom Services
      block:
        - name: Install additional service scripts
          copy:
            src: "{{ playbook_dir }}/restore/{{ item }}"
            dest: "/usr/local/bin/{{ item }}"
            mode: '0755'
          loop:
            - start-proton-vpnns.sh
            - vpnns-setup.sh
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: restore-services
          ignore_errors: yes

        - name: Install additional systemd services
          copy:
            src: "{{ playbook_dir }}/restore/{{ item }}"
            dest: "/etc/systemd/system/{{ item }}"
            mode: '0644'
          loop:
            - hbbr.service
            - rustdeskrelay.service
            - rustdesksignal.service
            - cloudflared-update.service
            - qbittorrent-vpnns.service
            - proton-vpnns.service
            - vpnns-init.service
            - virtual-gnome.service
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: restore-services
          ignore_errors: yes

        - name: Create required directories
          file:
            path: "{{ item }}"
            state: directory
            mode: '0755'
          loop:
            - /var/log/rustdesk
            - /etc/netns/vpnns
          become: true
          when: ansible_facts['os_family'] == "Debian"
          tags: restore-services
          ignore_errors: yes

        - name: Note about additional services
          debug:
            msg: |
              ‚ÑπÔ∏è Additional custom services restored:
              - RustDesk services (hbbr, relay, signal)
              - Cloudflared update service
              - ProtonVPN namespace services (vpnns-init, proton-vpnns)
              - qBittorrent VPN namespace service
              - Virtual GNOME service
              
              ‚ö†Ô∏è Manual steps required:
              - Install RustDesk binaries (hbbr/hbbs) to /usr/local/bin/ or /opt/rustdesk/
              - Restore /root/.config/rustdesk/id_ed25519 (RustDesk key)
              - Restore /etc/wireguard/proton.wg (ProtonVPN WireGuard config)
              - Enable/start services in this order:
                1. vpnns-init (must be enabled/started first for VPN namespace)
                2. proton-vpnns (requires vpnns-init)
                3. qbittorrent-vpnns (requires proton-vpnns)
                4. rustdeskrelay (if using /opt/rustdesk/hbbr)
                5. rustdesksignal (if using /opt/rustdesk/hbbs)
                6. hbbr (if using /usr/local/bin/hbbr)
                7. cloudflared-update (optional, auto-updates cloudflared)
                8. virtual-gnome (if using headless GNOME desktop)
                
                Example: systemctl enable --now vpnns-init proton-vpnns qbittorrent-vpnns rustdeskrelay rustdesksignal hbbr virtual-gnome
          tags: restore-services

      when: ansible_facts['os_family'] == "Debian"
      tags: restore-services
      rescue:
        - name: Log restore services failure
          debug:
            msg: "‚ö†Ô∏è Restore services configuration failed, continuing."
          tags: restore-services

    # üîπ Configure .zshrc
    - name: Ensure custom dotfiles config is in .zshrc
      ansible.builtin.blockinfile:
        path: "{{ lookup('env', 'HOME') }}/.zshrc"
        marker: "# {mark} DOTFILES CONFIG"
        block: |
          export DOTFILES_OPTS=(common network nnn) # adjust as needed; other options: not-cloud, nnn, network, phone
          if [ -f $HOME/git/dotfiles/zsh/common.zsh ]; then
              source $HOME/git/dotfiles/zsh/common.zsh
          fi
        create: yes
      tags: zshrc

    # üîπ Configure Neovim
    - name: Configure Neovim init.lua
      block:
        - name: Ensure .config/nvim directory exists
          ansible.builtin.file:
            path: "{{ lookup('env', 'HOME') }}/.config/nvim"
            state: directory
            mode: '0755'
            owner: "{{ lookup('env', 'USER') }}"
          become: false
          tags: nvim

        - name: Symlink Neovim init.lua configuration
          ansible.builtin.file:
            src: "{{ lookup('env', 'HOME') }}/git/dotfiles/.config/nvim/init.lua"
            dest: "{{ lookup('env', 'HOME') }}/.config/nvim/init.lua"
            state: link
            force: yes
          become: false
          tags: nvim

      rescue:
        - name: Log Neovim configuration failure
          debug:
            msg: "‚ö†Ô∏è Neovim configuration failed, continuing."
          tags: nvim
