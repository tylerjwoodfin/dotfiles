#!/bin/zsh

# folders
setopt cdablevars
export notes=$HOME/syncthing/md/notes
export docs=$HOME/syncthing/md/docs
export work=$HOME/syncthing/md/work
export workt=$HOME/syncthing/md/work/todo.md
export logpath=$HOME/syncthing/log
export cabinet=$HOME/syncthing/cabinet/settings.json
export log=$logpath/cabinet/$(date +%Y-%m-%d)/LOG_DAILY_$(date +%Y-%m-%d).log
export sprints=$HOME/syncthing/md/docs/sprints

# `sprint` is the latest sprint file
if [ -d "$HOME/syncthing/md/docs/sprints" ]; then
  export sprint=$(find "$HOME/syncthing/md/docs/sprints" -type f -name "sprint [0-9]*.md" | sort -V | tail -n 1)
fi


# Function: Edit a file in $notes with nvim
vn() {
    if [[ -z "$1" ]]; then
        echo "Error: No argument provided"
        return 1
    fi

    # Strip '.md' if necessary
    filename="${1%%.md}"

    # Check if the input starts with '/'
    if [[ "$filename" == /* ]]; then
        nvim "$filename.md"
    else
        nvim "$notes/$filename.md"
    fi
}

# Function: Retrieve the path of a file in $notes
n() {
    if [[ -z "$1" ]]; then
        echo "Error: No argument provided"
        return 1
    fi

    # Set the filename as a variable
    filename="$notes/$1.md"

    # Return the file path
    echo "$filename"
}

# cheat
function cheat() {
  local query="$*"
  local encoded_query=$(echo "$query" | sed 's/ /%20/g')
  curl "cheat.sh/$encoded_query"
}


# Set ls options
alias ls='ls -hal --color'

# Show calendar
alias cal='cal -B1 -A1; echo -e "\nUse ncal to display horizontally"'
alias ncal='ncal -B1 -A1'

# Use nvim as default editor
export EDITOR='nvim'
alias vim='nvim'

# fff config
export FFF_KEY_CHILD2="off"
export FFF_KEY_PARENT2="off"

# Quick navigation aliases
alias cdh='cd ~'
alias cdg='cd ~/git'
alias cdto='cd ~/git/tools'
alias cddo='cd ~/git/dotfiles'
alias cdrm='cd ~/git/remindmail'
alias cdc='cd ~/git/cabinet'
alias cdw='cd ~/git/tyler.cloud'
alias b='cd ../'
alias x='exit'
alias cc='clear'
cdl() { cd "$a"; ls; }

# Enable Colors ðŸŽ¨
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# Git aliases
alias glog='git log --graph --pretty=format:"%Cred%h%Creset %an: %s - %Creset %C(yellow)%d%Creset %Cgreen(%cr)%Creset" --abbrev-commit --date=relative'
alias gcm='git commit -m'
alias gch='git fetch && git checkout'
alias gb='git checkout -b'
alias gs='git status'
alias gclean='git branch --merged | egrep -v "(^\*|master|dev|main)" | xargs git branch -d'
alias gd='git diff'
alias gdd='git diff develop'
alias gp='git pull'
git config --global push.default current

gcam() {
    branch=$(git symbolic-ref --short HEAD)
    branch=${branch#*/}
    git add -A && git commit -m "$branch: $*"
}

# Useful scripts - see https://github.com/tylerjwoodfin
alias diary='python3 ~/git/tools/diary/main.py'
alias shorten='python3 ~/git/tools/shorten.py'
alias yt='python3 ~/git/tools/yt/main.py'
alias pitest='python3 ~/git/testfolder/test.py'
alias pibuild='python3 ~/git/tools/build/build.py'
alias turn='python3 ~/git/tools/kasalights/main.py'
alias notes='fff ~/syncthing/md/notes'
alias docs='fff ~/syncthing/md/docs'
alias work='fff ~/syncthing/md/work'
alias lofi='bash ~/git/tools/lofi.sh'
alias v='python3 ~/git/voicegpt/main.py'
alias bike='python3 ~/git/tools/bike/price_calculator.py'

# remindmail - see https://github.com/tylerjwoodfin/remindmail
rmm() {
    local save=""
    if [[ "$1" == "--save" ]]; then
        save="--save"
        shift
    fi

    local when=""
    local title=""
    local extra_args=()
    
    # Capture the full input
    local full_input="$*"

    # If there's a comma, separate 'when' and remaining input
    if [[ "$full_input" == *,* ]]; then
        when="${full_input%%,*}"
        full_input="${full_input#*,}"
    fi

    # Initialize flags to capture title and extra arguments
    local is_reading_title=true
    local current_arg=""

    # Read words in full_input and process each
    for word in ${(z)full_input}; do
        if $is_reading_title; then
            # Detect start of extra arguments
            if [[ "$word" == --* ]]; then
                is_reading_title=false
                extra_args+=("$word")
            else
                # Append word to title
                title+="$word "
            fi
        else
            # Process extra arguments
            if [[ "$word" == --* ]]; then
                # Start a new argument in extra_args
                if [[ -n "$current_arg" ]]; then
                    extra_args+=("${current_arg% }")
                fi
                current_arg="$word"
            else
                # Append to the current extra argument
                current_arg+=" $word"
            fi
        fi
    done

    # Add the last accumulated extra argument if any
    if [[ -n "$current_arg" ]]; then
        extra_args+=("${current_arg% }")
    fi

    # Trim spaces from when and title
    when="${when#"${when%%[![:space:]]*}"}"
    when="${when%"${when##*[![:space:]]}"}"
    title="${title#"${title%%[![:space:]]*}"}"
    title="${title%"${title##*[![:space:]]}"}"

    # Build the command
    local cmd="remind"
    [[ -n $title ]] && cmd+=" --title '$title'"
    [[ -n $when ]] && cmd+=" --when '$when'"
    [[ -n $save ]] && cmd+=" $save"

    # Add each extra argument to the command, quoted
    for arg in "${extra_args[@]}"; do
        arg="${arg#"${arg%%[![:space:]]*}"}"
        arg="${arg%"${arg##*[![:space:]]}"}"
        cmd+=" '$arg'"
    done

    eval $cmd
}

rmmt() {
    remind --title "$*" --when "tomorrow"
}

rmmy() {
    rmm --save "$@"
}

rmmty() {
    remind --title "$*" --when "tomorrow" --save
}

rmml() {
    remind --title "$*" --when "later"
}

worka() {
    # adds to work todo list
    local file_path="$HOME/syncthing/md/work/todo.md"
    local new_task="- [ ] # $*"
    
    # insert the new task below the "## to do" header
    awk -v task="$new_task" '
    BEGIN {added = 0} # Flag to check if task is added
    {
        if ($0 ~ /^## to do/ && added == 0) { # Find the "## to do" header
            print $0 # Print the header
            print task # Print the new task right after the header
            added = 1 # Set the flag to avoid adding task again
        } else {
            print $0 # Print other lines as they are
        }
    }' "$file_path" > tmpfile && mv tmpfile "$file_path"
}

plex() {
    python3 ~/git/tools/yt/main.py video "$@" -d ~/syncthing/video/YouTube
}

alias worka='worka'
alias rmmt='rmmt'
alias rmmy='rmmy'
alias rmmty='rmmty'
alias rmml='rmml'
alias rmmsl='rmm --later'
alias rmme='remind --edit'
alias rmmst='remind --show-tomorrow'
alias rmmsw='remind --show-week'
alias rmmj='remind --jira'
alias rmmti='remind -ti'
alias rmmtit='remind -ti --board Shopping --list-name Tyler'
alias rmmta='remind -ta'
alias rmmtai='remind -ta --board Shopping --list-name Tyler --item-name'
alias rmmtais='remind -ta --board Shopping --list-name Shared --item-name'
alias one-more-hour='python3 /home/tyler/git/tools/pihole/one_more_hour.py'

# Check weather
alias weather='curl wttr.in/?2QF'

# ollama
function llama() {
  local input="$*"
  ollama run llama3:latest "$input"
}


[ -z "$PS1" ] && return

# Aliases below this line won't be called during interactive sessions (e.g., scripts)
